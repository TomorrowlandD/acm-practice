# [NOIP2018 提高组] 铺设道路

[P5019 [NOIP2018 提高组\] 铺设道路 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P5019)

## 题目背景

NOIP2018 提高组 D1T1

## 题目描述

春春是一名道路工程师，负责铺设一条长度为 $n$ 的道路。 

铺设道路的主要工作是填平下陷的地表。整段道路可以看作是 $n$ 块首尾相连的区域，一开始，第 $i$ 块区域下陷的深度为 $d_i$ 。 

春春每天可以选择一段连续区间 $[L,R]$ ，填充这段区间中的每块区域，让其下陷深度减少 $1$。在选择区间时，需要保证，区间内的每块区域在填充前下陷深度均不为 $0$ 。 

春春希望你能帮他设计一种方案，可以在最短的时间内将整段道路的下陷深度都变为 $0$ 。

## 输入格式

输入文件包含两行，第一行包含一个整数 $n$，表示道路的长度。 第二行包含 $n$ 个整数，相邻两数间用一个空格隔开，第 $i$ 个整数为 $d_i$ 。

## 输出格式

输出文件仅包含一个整数，即最少需要多少天才能完成任务。

## 样例 #1

### 样例输入 #1

```
6   
4 3 2 5 3 5
```

### 样例输出 #1

```
9
```

## 提示

【样例解释】

一种可行的最佳方案是，依次选择： 
$[1,6]$、$[1,6]$、$[1,2]$、$[1,1]$、$[4,6]$、$[4,4]$、$[4,4]$、$[6,6]$、$[6,6]$。   

【数据规模与约定】

对于 $30\%$ 的数据，$1 ≤ n ≤ 10$ ；    
对于 $70\%$ 的数据，$1 ≤ n ≤ 1000$ ；     
对于 $100\%$ 的数据，$1 ≤ n ≤ 100000 , 0 ≤ d_i ≤ 10000$ 。





## 思路分析：

这题乍一看我们觉得是差分，但是这题没有必要使用差分来解决，我们可以使用贪心的思想，将这个问题抽象为：我们需要选择一个区间进行填坑，如果我们填大的坑的同时，顺带着填了小的坑，那么相当于小的坑就“免费“被我们顺带着填完了。

## 它就是一个贪心。

题目里给的样例是4，3，2，5，3，5；

可以选择一个区间进行“填坑”操作；

所以我们的贪心策略是：

### 若a[i]>a[i-1],计数器sum+=a[i]-a[i-1];

那么为什么这样贪心是对的呢？

### 贪心证明

假设现在有一个坑，但旁边又有一个坑。

你肯定会选择把两个同时减1；

那么小的坑肯定会被大的坑“带着”填掉。

大的坑也会减少a[i]-a[i-1]的深度，可以说是“免费的”；

所以说本题就可以直接采用贪心的思维直接解决。

## 代码实现

```cpp
#include<iostream>
using namespace std;
int n;
int a[100005];

int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	int sum = 0;
	for (int i = 1; i <= n; i++) {
		if (a[i] > a[i+1]) sum += a[i] - a[i + 1];
	}
	cout << sum;
	return 0;
}
```







## 方法二：

采用递推的方式：

用f[i]*f*[*i*]表示前i个坑所铺设的最少天数

那么要做的只需比较一下当前的a[i]*a*[*i*]（就是坑的深度）和a[i−1]*a*[*i*−1]，分两种情况：

如果a[i]<=a[i−1]*a*[*i*]<=*a*[*i*−1]，那么在填a[i−1]*a*[*i*−1]时就可以顺便把a[i]*a*[*i*]填上，这样显然更优，所以f[i]=f[i−1]*f*[*i*]=*f*[*i*−1];

否则的话，那么在填a[i−1]*a*[*i*−1]时肯定要尽量把a[i]*a*[*i*]一块填上，a[i]*a*[*i*]剩余的就单独填。。

所以，f[i]=f[i−1]+(a[i]−a[i−1])*f*[*i*]=*f*[*i*−1]+(*a*[*i*]−*a*[*i*−1])。

初始化f[1]=a[1]*f*[1]=*a*[1]，向后推就行了。
