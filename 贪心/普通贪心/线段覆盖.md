# P1803  凌乱的yyy / 线段覆盖

[P1803 凌乱的yyy / 线段覆盖 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1803)

## 题目背景

快 noip 了，yyy 很紧张！

## 题目描述

现在各大 oj 上有 $n$ 个比赛，每个比赛的开始、结束的时间点是知道的。

yyy 认为，参加越多的比赛，noip 就能考的越好（假的）。

所以，他想知道他最多能参加几个比赛。

由于 yyy 是蒟蒻，如果要参加一个比赛必须善始善终，而且不能同时参加 $2$ 个及以上的比赛。

## 输入格式

第一行是一个整数 $n$，接下来 $n$ 行每行是 $2$ 个整数 $a_{i},b_{i}\ (a_{i}<b_{i})$，表示比赛开始、结束的时间。

## 输出格式

一个整数最多参加的比赛数目。

## 样例 #1

### 样例输入 #1

```
3
0 2
2 4
1 3
```

### 样例输出 #1

```
2
```

## 提示

- 对于 $20\%$ 的数据，$n \le 10$；
- 对于 $50\%$ 的数据，$n \le 10^3$；
- 对于 $70\%$ 的数据，$n \le 10^{5}$；
- 对于 $100\%$ 的数据，$1\le n \le 10^{6}$，$0 \le a_{i} < b_{i} \le 10^6$。





## 思路：

+ 贪心策略：我们要尽可能多的参加比赛，那么我们结束比赛的时间就应该尽可能早，这样我们才能参加更多的比赛。
+ 我们想到，既然可以按照结束时间排序，那么我们能根据开始时间排序吗？不好意思！不可以，我们可以举出明显的反例，如果我们根据开始时间来排序的话！比如我们第一场比赛是[0,100]，后面几场比赛是 [1,2]，[3,5]等等，这种情况我们根据这种策略得到的就不是最多的答案，但是上面那种排序方式得到的答案就是最多的！我们可以试着找一下反例，举不出明显的反例！



## 实现

+ 我们首先需要一个结构体，用来存储每一场比赛的开始时间，结束时间，我们要根据结束时间来升序排列，并且比较当前比赛的开始时间是否小于上一场比赛的结束时间，如果小于，则表明我们不能参加当前比赛，否则可以。
+ 我们可以使用一个变量last，记录上一场比赛的结束时间。



## 代码：

```cpp
//这道题不能按照左端点进行排序，只能按照右端点排序，因为按照左端点排序
//得到的答案不一定是比赛的最多场次
#include<iostream>
#include<algorithm>
using namespace std;
struct p {
	int start;
	int end;
}a[1000005];
int n,last,ans;
//按结束时间升序排列
bool compare(p s1, p s2) {
	return s1.end < s2.end;
}
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].start >> a[i].end;
	}
	sort(a + 1, a + 1 + n, compare);
	for (int i = 1; i <= n; i++) {
        //与上一场比赛的结束时间相比，如果大于等于上一场比赛的结束时间，就可以打这场比赛
		if (a[i].start >= last) {
			last = a[i].end;
			ans++;
		}
	}
	cout << ans << endl;
	return 0;
}


```







