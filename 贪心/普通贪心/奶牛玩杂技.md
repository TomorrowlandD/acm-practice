# [USACO05NOV] 奶牛玩杂技

[P1842 [USACO05NOV\] 奶牛玩杂技 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1842)

## 题目背景

Farmer John 养了 $N$ 头牛，她们已经按 $1\sim N$ 依次编上了号。FJ 所不知道的是，他的所有牛都梦想着从农场逃走，去参加马戏团的演出。可奶牛们很快发现她们那笨拙的蹄子根本无法在钢丝或晃动的的秋千上站稳（她们还尝试过把自己装在大炮里发射出去，但可想而知，结果是悲惨的） 。最终，她们决定练习一种最简单的杂技：把所有牛都摞在一起， 比如说， 第一头牛站在第二头的身上， 同时第二头牛又站在第三头牛的身上...最底下的是第 $N$ 头牛。

## 题目描述

每头牛都有自己的体重以及力量，编号为 $i$ 的奶牛的体重为 $W_i$，力量为 $S_i$。

当某头牛身上站着另一些牛时它就会在一定程度上被压扁，我们不妨把它被压扁的程度叫做它的压扁指数。对于任意的牛，她的压扁指数等于摞在她上面的所有奶牛的总重（当然不包括她自己）减去它的力量。奶牛们按照一定的顺序摞在一起后， 她们的总压扁指数就是被压得最扁的那头奶牛的压扁指数。

你的任务就是帮助奶牛们找出一个摞在一起的顺序，使得总压扁指数最小。

## 输入格式

第一行一个整数 $N$。

接下来 $N$ 行，每行两个整数 $W_i$ 和 $S_i$。

## 输出格式

一行一个整数表示最小总压扁指数。

## 样例 #1

### 样例输入 #1

```
3
10 3
2 5
3 3
```

### 样例输出 #1

```
2
```

## 提示

对于 $100\%$ 的数据，$1 \le N \le 5\times 10^4$，$1 \le W_i \le 10^4$，$1 \le S_i \le 10^9$。

## 思路：

+  本题我们刚拿到题，我们可以先进行模拟，我们可以定义一个结构体，存储奶牛的两个性质，力量和重量。一开始并没有什么太好的思路去计算最小的压扁指数，但是我们可以凭直觉猜想一下，我们要使得这一群奶牛当中，被压得最扁的奶牛的压扁指数尽可能的小，那么我们是不是就是要让最扁的那头奶牛的上面的所有牛的体重之和尽可能的小，并且让这头牛的力量尽可能的大，对吧？

+  所以说我们最低的压扁指数不仅仅与体重有关，也与牛的力量有关，所以说我们在采取排序策略的同时，我们不能够仅仅根据体重或者是根据力量这一个元素来排序，我们一定要结合两个属性来排序，我们不妨猜想根据`体重和力量的某种组合方式`来进行排序，可以是``重量与力量之差``来排序，也可以是`力量与重量之和`来排序，只要我们证明，我们以某种排序规则下得到的总压扁指数是最小的，那么我们就成功证明了我们方案的可行性，对吧？

## 贪心策略的证明：

1. 我们不妨先猜想按照力量和重量之和来排序，力量与重量之和小的排前面，反之则排后面。那么我们就需要证明，在这种排序规则之下，我们得到的总压扁指数就是最小的总压扁指数我们假设第i头牛它的压扁指数是总压扁指数，那么它前面所有牛的总重量是$w_1$+$w_2$+....w(i-1),此时的总压扁指数为==w1+w2+....+w(i-1)-si==,那么我们如何去证明这个压扁指数就是最小的呢？我们可以试着交换任意两行奶牛，比如我们让第i头奶牛与第i-1头奶牛交换，那么此时的总压扁指数就变成了==w1+w2+...wi-s(i-1)==,我们只需要证明 ==w1+w2+..w(i-1)-si<w1+w2+...+wi-s(i-1)==即可由于我们是按照体重与力量之和来升序排列的，那么我们肯定就有==w(i-1)+s(i-1)<wi+si==这个式子,观察上述不等式，只有wi,w(i-1),si,s(i-1)四个地方不一样，我们有`w(i-1)+s(i-1)<wi+si`这个式子两边移项以后可以得到==w(i-1)-si<wi-s(i-1)==，刚好是上面的式子变形得到的，那么我们就成功证明了我们策略的可行性

2. 其它的情况，例如按照重量与力量之差来升序排列，这种方式我们也是可以猜想的，我们也可也自行证明这个策略的可行性，如果我们能够证明我们当前策略的办法就是最优解，我们就可以采纳，不过这道题在这种情况下，是不可取的，我们也可以自行证明一下。

## 代码：

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
const int N = 5e4 + 10;
//用结构体来储存重量与力量两个属性
struct node {
	int w;
	int s;
}a[N];
int n;
//按照力量与重量之和来升序排列
bool compare(node A, node b) {
	return A.w + A.s < b.w + b.s;
}
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].w >> a[i].s;
	}
	sort(a + 1, a + 1 + n, compare);
//答案先最随便初始化为一个最小值
	int res = -2e9;
	int t = 0;
	for (int i = 1; i <= n; i++) {
		//结果取压扁指数的最大值
		res = max(res, t - a[i].s);
		t += a[i].w;
	}
	cout << res;
	return 0;
}

```

## 总结：

贪心策略很多时候都是根据我们的直觉来得到思路的，但是我们有时并不能像这道题一样，给出严格的证明过程，但是我们当我们举不出任何反例时，我们就可以试试我们的贪心策略了！

总而言之，贪心策略很多时候都是我们的常识告诉我们应该这么做，只要我们举不出任何的反例，我们就可以尝试贪心策略，有时候我们也可以去尝试严格的数学证明我们的策略是正确的!