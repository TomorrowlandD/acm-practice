# P1209 [USACO1.3] 修理牛棚 Barn Repair

[P1209 [USACO1.3\] 修理牛棚 Barn Repair - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1209)

## 题目描述

在一个月黑风高的暴风雨夜，Farmer John 的牛棚的屋顶、门被吹飞了 好在许多牛正在度假，所以牛棚没有住满。   

牛棚一个紧挨着另一个被排成一行，牛就住在里面过夜。有些牛棚里有牛，有些没有。 所有的牛棚有相同的宽度。   宽度为1

自门遗失以后，Farmer John 必须尽快在牛棚之前竖立起新的木板。他的新木材供应商将会供应他任何他想要的长度，但是吝啬的供应商只能提供有限数目的木板。 Farmer John 想将他购买的木板总长度减到最少。

给出 $m,s,c$，表示木板最大的数目、牛棚的总数、牛的总数；以及每头牛所在牛棚的编号，请算出拦住所有有牛的牛棚所需木板的最小总长度。

## 输入格式

一行三个整数 $m,s,c$，意义如题目描述。   
接下来 $c$ 行，每行包含一个整数，表示牛所占的牛棚的编号。

## 输出格式

输出一行一个整数，表示所需木板的最小总长度。

## 样例 #1

### 样例输入 #1

```
4 50 18
3 
4 
6 
8 
14
15 
16 
17 
21
25 
26 
27 
30 
31 
40 
41 
42 
43
```

### 样例输出 #1

```
25
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le m \le 50$，$1\le c \le s \le 200$。 

USACO Training Section 1.3







## 思路：

+ 题目很多信息，我们首先捋清楚题目的意思。s与解题无关，我们应该剔除没用的信息，供应商最多可以提供m块板子，有c个牛棚中住了牛，我们需要对这c个牛棚进行修补，每个牛棚需要长度为1的板子，但是我们的总板子数目不超过m个，因此，当m＜c时，我们需要对有些牛棚的板子进行延长，比如我们对编号为2，3的两个牛棚，我们使用一块长度为2的木板来修复它，直到我们使用的木板总数等于m为止。
+ 我们可以有一个思路，先对每个有牛的牛棚进行分配一块长度为1的木板，如果供应的木板总数≥牛的数量，那么我们的答案就是c，每个牛棚分配一块长度为1的木板即可，否则，我们就得使用连续的木板来修复多个牛棚。比如编号为3和8的木板，我们使用长度为6的木板修复，不过因为我们一开始每个牛棚一个分配了长度为1的木板，所以只需要在原来答案的基础上加上8-3-1即可，就是4，所以说得数出它们之间隔了几个牛棚。
+ 由上面的思路，我们得对有牛的牛棚数组==a==进行排序，并使用另外一个数组==d==，用来表示==a==中相邻元素之间所隔着的牛棚数量
+ 先对牛棚数组a排序，并给每一个牛棚分配一个长度为1的木板：

```cpp
for (int i = 1; i <= c; i++) cin >> a[i];
//先给每个有牛的牛棚分配一块木板，如果最大木板数量不够用的话，就得
//将某些木板连起来了。
int ans = c;
sort(a + 1, a + 1 + c);
```

+ 然后，我们计算出a中相邻元素的木板数量，并对d数组排序

```cpp
	for (int i = 2; i <= c; i++) d[i - 1] = a[i] - a[i - 1] - 1;
	//d数组总共有c-1个元素
	sort(d + 1, d + c);
```

+ 如果m<c的话，我们就每次选择d数组中最小的那个元素，因为它们之间相隔的木板数目最少，我们所需要付出的木板长度代价越低，这就是贪心思想所对应的局部最优解。以往下去，我们使用的木板长度肯定是最少的，最终得到全局最优解。





## 代码：

```cpp
#include<iostream>
using namespace std;
#include<algorithm>
int a[205];		//作为有牛的牛棚的编号
int d[205];		//作为相邻两个牛棚之间间隔的牛棚的数量
int m, s, c;
int main()
{
	cin >> m >> s >> c;
	for (int i = 1; i <= c; i++) cin >> a[i];
	//先给每个有牛的牛棚分配一块木板，如果最大木板数量不够用的话，就得
	//将某些木板连起来了。
	int ans = c;
	sort(a + 1, a + 1 + c);
	for (int i = 2; i <= c; i++) d[i - 1] = a[i] - a[i - 1] - 1;
	sort(d + 1, d + c);
	//如果最多提供的板子数量小于牛的数量，这时候就不能每头有牛的牛棚都分配板子了，就得将某些牛棚的板子连起来。
	if (m < c) {
		//d数组总共有c-m个元素，因为有c头牛，最多提供m块板子
		//我们每次贪心的选择相隔牛棚数最少的牛棚，这样我们的代价越低，得到的结果越小，
		for (int i = 1; i <= c - m; i++) ans += d[i];
	}
	cout << ans << endl;
	return 0;
}
```





## 总结与思考

+ 做信息学竞赛的题目，我们最重要的能力就是快速阅读有用信息的能力，并建立出自己的模型，或者是画出对应的草图，然后在草稿纸上推演出对应的数学关系，最后用代码表示出来

