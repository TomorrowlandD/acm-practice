# P1748 陶陶摘苹果（升级版）

[P1478 陶陶摘苹果（升级版） - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1478)

## 题目描述

又是一年秋季时，陶陶家的苹果树结了 $n$ 个果子。陶陶又跑去摘苹果，这次他有一个 $a$ 公分的椅子。当他手够不着时，他会站到椅子上再试试。

这次与 NOIp2005 普及组第一题不同的是：陶陶之前搬凳子，力气只剩下 $s$ 了。当然，每次摘苹果时都要用一定的力气。陶陶想知道在 $s<0$ 之前最多能摘到多少个苹果。

现在已知 $n$ 个苹果到达地上的高度 $x_i$，椅子的高度 $a$，陶陶手伸直的最大长度 $b$，陶陶所剩的力气 $s$，陶陶摘一个苹果需要的力气 $y_i$，求陶陶最多能摘到多少个苹果。

## 输入格式

第 $1$ 行：两个数 苹果数 $n$，力气 $s$。

第 $2$ 行：两个数 椅子的高度 $a$，陶陶手伸直的最大长度 $b$。

第 $3$ 行~第 $3+n-1$ 行：每行两个数 苹果高度 $x_i$，摘这个苹果需要的力气 $y_i$。

## 输出格式

只有一个整数，表示陶陶最多能摘到的苹果数。

## 样例 #1

### 样例输入 #1

```
8 15
20 130
120 3
150 2
110 7
180 1
50 8
200 0
140 3
120 2
```

### 样例输出 #1

```
4
```

## 提示

对于 $100\%$ 的数据，$n\leq 5000$, $a\leq 50$, $b\leq 200$, $s\leq 1000$, $x_i\leq 280$, $y_i\leq 100$。







## 思路：

+ 我们要在有限的力气内，摘取尽可能多的果子，那么根据贪心策略，我们只需要每次摘果子的时候，耗费的力气是最小的（这也就是局部最优），那么我们最终摘到的果子的数量必然是最多的（全局最优），局部最优可以推出全局最优，并且我们举不出明显的反例，我们的直觉也告诉我们，就应该这么做，那么我们就贪下去吧！



## 实现过程：

+ 首先，我们可以采用一个结构体来存储果子的两个属性（果子的高度和摘取果子所需要的力气），并且我们只需要根据摘取果子所需要的力气来升序排列，那么我们每次选取需要力气的果子（前提是要能摘得到，即高度≤==a+b==），并一直循环下去就行了
+ 如果我们的力气大于等于当前需要摘到的苹果的最小力气，我们就将循环执行下去，否则，直接退出循环就行了，因为我们连需要消耗力气最小的苹果都摘不到了，自然就摘不到其余的任何苹果了。



## 代码：

```cpp
#include<iostream>
#include<algorithm>
using namespace std;
struct apple {
	int h;
	int y;
}A[5005];
int n, s;
int a, b;
//自定义排序函数
bool compare(apple p, apple q) {
	return p.y < q.y;
}
int main()
{
	cin >> n >> s;
	cin >> a >> b;
	for (int i = 1; i <= n; i++) cin >> A[i].h >> A[i].y;
    //按需要摘取的力气来升序排列
	sort(A + 1, A + 1 + n, compare);
	long long ans = 0;
	for (int i = 1; i <= n; i++) {
	    //这里可以取等号
		if (s >= A[i].y) {
			//摘到可以摘到的需要力气最小的苹果
			if (a + b >= A[i].h) {
				s -= A[i].y;
				ans++;
			}
		}
        //如果当前的力气小于需要消耗力气最小的苹果，那么我们直接退出循环
		else break;
	}
	cout << ans;
	return 0;
}
```



