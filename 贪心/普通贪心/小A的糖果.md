# P3817 小A的糖果

[P3817 小A的糖果 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P3817)

## 题目描述

小 A 有 $n$ 个糖果盒，第 $i$ 个盒中有 $a_i$ 颗糖果。

小 A 每次可以从其中一盒糖果中吃掉一颗，他想知道，要让任意两个相邻的盒子中糖的个数之和都不大于 $x$，至少得吃掉几颗糖。

## 输入格式

输入的第一行是两个用空格隔开的整数，代表糖果盒的个数 $n$ 和给定的参数 $x$。

第二行有 $n$ 个用空格隔开的整数，第 $i$ 个整数代表第 $i$ 盒糖的糖果个数 $a_i$。

## 输出格式

输出一行一个整数，代表最少要吃掉的糖果的数量。

## 样例 #1

### 样例输入 #1

```
3 3
2 2 2
```

### 样例输出 #1

```
1
```

## 样例 #2

### 样例输入 #2

```
6 1
1 6 1 2 0 4
```

### 样例输出 #2

```
11
```

## 样例 #3

### 样例输入 #3

```
5 9
3 1 4 1 5
```

### 样例输出 #3

```
0
```

## 提示

#### 样例输入输出 1 解释

吃掉第 2 盒中的一个糖果即可。

---

#### 样例输入输出 2 解释

第 2 盒糖吃掉 $6$ 颗，第 4 盒吃掉 $2$ 颗，第 6 盒吃掉 $3$ 颗。

---

#### 数据规模与约定

- 对于 $30\%$ 的数据，保证 $n \leq 20$，$a_i, x \leq 100$。
- 对于 $70\%$ 的数据，保证 $n \leq 10^3$，$a_i, x \leq 10^5$。
- 对于 $100\%$ 的数据，保证 $2 \leq n \leq 10^5$，$0 \leq a_i, x \leq 10^9$。







## 思路：

+ 我们这题仍然能够采用贪心的策略，我们怎么样去吃糖果能够使得相邻两个盒子的糖果数量不超过x，并且吃的糖果数量最少呢？我们可以从局部最优的条件出发，只要我们每一次吃掉的糖果数量最少，当我们到达最后一个盒子时，我们吃掉的总糖果数量一定是最少的。局部最优就是每次吃掉最少的糖果，全局最优就是最终吃掉的糖果数量最少。局部最优能够推出全局最优，并且我们举不出明显的反例，那么我们就可以试着采用贪心的策略！




## 实现的过程

+ 我们如何实现每次吃掉最少的糖果并且满足相邻两个糖果的数量不大于x呢？我们只需要从第2个盒子开始，每次判断当前盒子与上一个盒子的糖果数量之和是否＞x，如果＞x，我们就吃掉多出的那些糖果，这样，我们每次吃掉的糖果数量一定是最少的，这也就是局部最优
+ 我们采用这种方案，需要对第一个盒子进行特殊判断，确保第一个盒子的糖果数量不超过x。如果超过x，我们就吃掉一部分糖果，直到第一个盒子只剩下x个糖果即可

```cpp
	//确保第一个盒子的糖果数量小于等于x
	if (a[1] > x) {
		ans += a[1]-x;
		a[1] =x;
	}
	//从第二个盒子开始判断，确保第i个盒子和第i-1个盒子的糖果数量之和不大于x
	for (int i = 2; i <= n; i++) {
		if (a[i] + a[i - 1] > x) {
			ans += a[i] + a[i - 1] - x;
			a[i] = x - a[i - 1];
		}
	}
```





## 代码

```cpp
#include<iostream>
using namespace std;
const int N = 1e5 + 10;
long long  a[N];
long long n, x;
int main()
{
	cin >> n >> x;
	long long ans = 0;
	for (int i = 1; i <= n; i++) cin >> a[i];
	//特判第1个元素，如果第一个元素的数量大于x，就让他变为x
	if (a[1] > x) {
		ans += a[1]-x;
		a[1] =x;
	}
	for (int i = 2; i <= n; i++) {
		if (a[i] + a[i - 1] > x) {
			ans += a[i] + a[i - 1] - x;
			a[i] = x - a[i - 1];
		}
	}
	cout << ans;
	return 0;
}
```



