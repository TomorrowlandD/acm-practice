# P2240【深基12.例1】部分背包问题

[P2240 【深基12.例1】部分背包问题 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P2240)

## 题目描述

阿里巴巴走进了装满宝藏的藏宝洞。藏宝洞里面有 $N(N \le 100)$ 堆金币，第 $i$ 堆金币的总重量和总价值分别是 $m_i,v_i(1\le m_i,v_i \le 100)$。阿里巴巴有一个承重量为 $T(T \le 1000)$ 的背包，但并不一定有办法将全部的金币都装进去。他想装走尽可能多价值的金币。所有金币都可以随意分割，分割完的金币重量价值比（也就是单位价格）不变。请问阿里巴巴最多可以拿走多少价值的金币？

## 输入格式

第一行两个整数 $N,T$。

接下来 $N$ 行，每行两个整数 $m_i,v_i$。

## 输出格式

一个实数表示答案，输出两位小数

## 样例 #1

### 样例输入 #1

```
4 50
10 60
20 100
30 120
15 45
```

### 样例输出 #1

```
240.00
```







## 思路：

+ 我们需要在有限的背包容量内，尽可能带走价值高的黄金总量，那么我们自然而然想到，只要我们单位重量的黄金价值高，那么我们在有限的背包容量内，我们带走的黄金的价值总量肯定是最多的，对吧！这里的局部最优就是每次尽可能取价值高的金币堆，全局最优就是我们消耗完背包容量，取到的黄金总价值最高，局部最优可以推出全局最优，那么我们就试试贪心策略！



## 实现

+ 我们首先需要一个结构体，来存储黄金堆的重量，总价值，与它的平均黄金价值，并且我们需要对平均黄金价值进行升序排列，每次尽可能多的装平均价值高的黄金堆
+ 当我们的背包容量大于当前黄金堆的总重量时，我们就将黄金全部带走，否则，我们就带走我们需要的那部分黄金，并退出循环



## 代码：

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
struct node {
	double m;
	double v;
    //注意，平均值开成double类型
	double av;
}a[105];
int n, t;
//平均黄金价值高排的在前面
bool compare(node s1, node s2) {
	return s1.av > s2.av;
}
int main()
{
	cin >> n >> t;
	for (int i = 1; i <= n; i++) {
		cin >> a[i].m >> a[i].v;
		a[i].av = a[i].v / a[i].m;
	}
	sort(a + 1, a + 1 + n, compare);
	double sum = 0;
	for (int i = 1; i <= n; i++) {
        //如果背包容量大于等于黄金堆的数量时，就全部带走
		if (t >= a[i].m) {
			sum += a[i].v;
			t -= a[i].m;
		}
		else {
            //否则，只带走我们只能装下的那部分，并退出循环
			sum += a[i].av * t;
			break;
		}
	}
    //保留两位小数的输出
	printf("%.2lf", sum);
	return 0;
}

```

