# 地毯

## 题目描述

在 $n\times n$ 的格子上有 $m$ 个地毯。

给出这些地毯的信息，问每个点被多少个地毯覆盖。

## 输入格式

第一行，两个正整数 $n,m$。意义如题所述。

接下来 $m$ 行，每行两个坐标 $(x_1,y_1)$ 和 $(x_2,y_2)$，代表一块地毯，左上角是 $(x_1,y_1)$，右下角是 $(x_2,y_2)$。

## 输出格式

输出 $n$ 行，每行 $n$ 个正整数。

第 $i$ 行第 $j$ 列的正整数表示 $(i,j)$ 这个格子被多少个地毯覆盖。

## 样例 #1

### 样例输入 #1

```
5 3
2 2 3 3
3 3 5 5
1 2 1 4
```

### 样例输出 #1

```
0 1 1 1 0
0 1 1 0 0
0 1 2 1 1
0 0 1 1 1
0 0 1 1 1
```

## 提示

### 样例解释

覆盖第一个地毯后：

| $0$  | $0$  | $0$  | $0$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $0$  | $0$  | $0$  | $0$  |
| $0$  | $0$  | $0$  | $0$  | $0$  |

覆盖第一、二个地毯后：

| $0$  | $0$  | $0$  | $0$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $2$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |

覆盖所有地毯后：

| $0$  | $1$  | $1$  | $1$  | $0$  |
| :--: | :--: | :--: | :--: | :--: |
| $0$  | $1$  | $1$  | $0$  | $0$  |
| $0$  | $1$  | $2$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |
| $0$  | $0$  | $1$  | $1$  | $1$  |

---

### 数据范围

对于 $20\%$ 的数据，有 $n\le 50$，$m\le 100$。

对于 $100\%$ 的数据，有 $n,m\le 1000$。

## 维差分的过程

![img](https://img2024.cnblogs.com/blog/3476421/202408/3476421-20240811114504273-1151102560.png)

+ 先对每一行做差分操作，然后逐行还原就行了



## 代码：

```
#include<bits/stdc++.h>
using namespace std;
const int N=1005;
int a[N][N];
int n,m;
int main()
{
    cin>>n>>m;
    while(m--){
        int x1, y1, x2, y2;
        cin >> x1 >> y1 >> x2 >> y2;
        // 逐行做差分操作
        for(int i=x1;i<=x2;i++){
            a[i][y1]++;
            a[i][y2+1]--;
        }
    }
    //逐行做还原
    for(int i=1;i<=n;i++){
        for(int j=1;j<=n;j++){
            a[i][j]+=a[i][j-1];
            cout<<a[i][j]<<' ';
       }
       cout<<'\n';
    }
    return 0;
}
```

