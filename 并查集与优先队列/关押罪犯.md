# P1525 [NOIP2010 提高组] 关押罪犯

[P1525 [NOIP2010 提高组\] 关押罪犯 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1525)

## 题目背景

NOIP2010 提高组 T3

## 题目描述

S 城现有两座监狱，一共关押着 $N$ 名罪犯，编号分别为 $1\sim N$。他们之间的关系自然也极不和谐。很多罪犯之间甚至积怨已久，如果客观条件具备则随时可能爆发冲突。我们用“怨气值”（一个正整数值）来表示某两名罪犯之间的仇恨程度，怨气值越大，则这两名罪犯之间的积怨越多。如果两名怨气值为 $c$ 的罪犯被关押在同一监狱，他们俩之间会发生摩擦，并造成影响力为 $c$ 的冲突事件。

每年年末，警察局会将本年内监狱中的所有冲突事件按影响力从大到小排成一个列表，然后上报到 S 城 Z 市长那里。公务繁忙的 Z 市长只会去看列表中的第一个事件的影响力，如果影响很坏，他就会考虑撤换警察局长。

在详细考察了 $N$ 名罪犯间的矛盾关系后，警察局长觉得压力巨大。他准备将罪犯们在两座监狱内重新分配，以求产生的冲突事件影响力都较小，从而保住自己的乌纱帽。假设只要处于同一监狱内的某两个罪犯间有仇恨，那么他们一定会在每年的某个时候发生摩擦。

那么，应如何分配罪犯，才能使 Z 市长看到的那个冲突事件的影响力最小？这个最小值是多少？

## 输入格式

每行中两个数之间用一个空格隔开。第一行为两个正整数 $N,M$，分别表示罪犯的数目以及存在仇恨的罪犯对数。接下来的 $M$ 行每行为三个正整数 $a_j,b_j,c_j$，表示 $a_j$ 号和 $b_j$ 号罪犯之间存在仇恨，其怨气值为 $c_j$。数据保证 $1<a_j\leq b_j\leq N, 0 < c_j\leq 10^9$，且每对罪犯组合只出现一次。

## 输出格式

共一行，为 Z 市长看到的那个冲突事件的影响力。如果本年内监狱中未发生任何冲突事件，请输出 `0`。

## 样例 #1

### 样例输入 #1

```
4 6
1 4 2534
2 3 3512
1 2 28351
1 3 6618
2 4 1805
3 4 12884
```

### 样例输出 #1

```
3512
```

## 提示

**输入输出样例说明**

罪犯之间的怨气值如下面左图所示，右图所示为罪犯的分配方法，市长看到的冲突事件影响力是 $3512$（由 $2$ 号和 $3$ 号罪犯引发）。其他任何分法都不会比这个分法更优。

![](https://cdn.luogu.com.cn/upload/image_hosting/uia11zcq.png)

**数据范围**  

对于 $30\%$ 的数据有 $N\leq 15$。

对于 $70\%$ 的数据有 $N\leq 2000,M\leq 50000$。  

对于 $100\%$ 的数据有 $N\leq 20000,M\leq 100000$。







 ## 代码：

```cpp
#include<algorithm>
#include<iostream>
using namespace std;
struct node {
	int a, b, c;
}e[1000005];
int n, m, fa[40005];
bool compare(node s1, node s2) {
	return s1.c > s2.c;
}
int find(int x) {
	if (fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}
void merge(int x, int y) {
	fa[find(y)] = find(x);
}
int main()
{
	cin >> n >> m;
	for (int i = 1; i <= m; i++) cin >> e[i].a >> e[i].b >> e[i].c;
	sort(e + 1, e + 1 + m, compare);
	for (int i = 1; i <= 2 * n; i++) fa[i] = i;
	for (int i = 1; i <= m; i++) {
		int a = e[i].a, b = e[i].b;
		if (find(a) == find(b)) {
			cout << e[i].c;
			return 0;
		}
		merge(a, b + n);
		merge(b, a + n);
	}
	cout << 0;
	return 0;
}
```



### 思路分析

1. **问题定义**：

   - 给定`n`个罪犯和`m`个仇恨关系，每个仇恨关系由三个整数`(a, b, c)`表示，其中`a`和`b`是罪犯的编号，`c`是他们之间的怨气值。

   - 目标是将罪犯分配到两座监狱中，使得产生的最大冲突事件影响力（即任意两个在同一座监狱中的有仇恨关系的罪犯之间的最大怨气值）最小。

   - 给你m对矛盾关系,**每对关系分别涉及到x，y两人**,矛盾值为w

     请你判断**分配**x和y到**两个集合**中，能否避免冲突

     如**能避免**请输出0，如果**冲突不可避免**，请输出**最小的矛盾值**

2. **代码实现**：

   + 本题，因为说了有“**边权值**”（我理解为矛盾值），所以**要求出现矛盾情况下**的**最小边权值**显然是**需要排序**的那么问题又来了，我们要按照什么方法进行分配呢？我们不妨这样想：两个人a，b有仇，那么把他们放在一起显然会打起来，那么我们还不如**把a与b的其他敌人放在一起**，因为这样**可能会出现“敌人的敌人就是朋友”的情况**，**恰好a与b的其他敌人之间没有矛盾，那么他们就可以放在同一个集合中，反之b对a亦然**。

### 代码作用

这段代码旨在解决“关押罪犯”问题，即如何分配罪犯到两个监狱中，以最小化市长看到的影响力最大的冲突事件。代码通过并查集（Union-Find）数据结构和贪心算法的结合来实现这一目标。

### 为什么这么做

1. **贪心策略**：
   - 由于题目要求最小化市长看到的影响力最大的冲突事件，一个直观的策略是尽可能先处理怨气值较大的冲突。因此，代码首先将所有冲突按怨气值从大到小排序。

2. **并查集（Union-Find）**：
   - 并查集是一种树型的数据结构，用于处理一些不交集的合并及查询问题。在这里，每个罪犯都可以看作是一个节点，开始时每个节点都是一个独立的集合。
   - 代码中，并查集被用来跟踪罪犯之间的分组情况。由于有两座监狱，我们可以将每个罪犯的编号映射到两个不同的集合中（例如，`a` 映射到 `a` 和 `a+n`），分别代表两个监狱。
   - 当处理一个冲突时，我们检查两个罪犯是否已经在同一个集合中（即同一个监狱内）。如果是，则无法避免这个冲突，输出这个冲突的影响力并终止程序。
   - 如果不是，我们将这两个罪犯分别放入两个监狱（即合并到两个不同的集合中），以避免这个冲突。

3. **为什么将罪犯编号映射到 `a+n`**：
   - 这是因为我们需要区分两个监狱中的罪犯。简单地使用 `1` 到 `N` 的编号不足以表示两个独立的监狱。通过将罪犯编号 `a` 映射到 `a` 和 `a+n`，我们可以确保两个监狱的编号空间是独立的，从而避免混淆。
   - 例如，如果 `N=4`，则第一个监狱的罪犯编号为 `1, 2, 3, 4`，第二个监狱的罪犯编号为 `5, 6, 7, 8`（即 `1+4, 2+4, 3+4, 4+4`）。

4. **终止条件**：
   - 如果在处理完所有冲突之前，发现了一对已经处于同一监狱的罪犯（即他们之间的冲突无法避免），则输出这对罪犯之间的怨气值，因为这是市长将看到的影响力最大的冲突事件。
   - 如果处理完所有冲突都没有发现这样的情况，则输出 `0`，表示可以通过合适的分配避免所有冲突。

### 总结

通过贪心策略和并查集的结合，这段代码有效地解决了“关押罪犯”问题，通过最小化市长看到的影响力最大的冲突事件来分配罪犯到两个监狱中。













