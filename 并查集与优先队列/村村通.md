# P1536 村村通

[P1536 村村通 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1536)

## 题目描述

某市调查城镇交通状况，得到现有城镇道路统计表。表中列出了每条道路直接连通的城镇。市政府 "村村通工程" 的目标是使全市任何两个城镇间都可以实现交通（但不一定有直接的道路相连，只要相互之间可达即可）。请你计算出最少还需要建设多少条道路？

## 输入格式

输入包含若干组测试数据，每组测试数据的第一行给出两个用空格隔开的正整数，分别是城镇数目 $n$ 和道路数目 $m$ ；随后的 $m$ 行对应 $m$ 条道路，每行给出一对用空格隔开的正整数，分别是该条道路直接相连的两个城镇的编号。简单起见，城镇从 $1$ 到 $n$ 编号。

注意：两个城市间可以有多条道路相通。

**在输入数据的最后，为一行一个整数 $0$，代表测试数据的结尾。**

## 输出格式

对于每组数据，对应一行一个整数。表示最少还需要建设的道路数目。

## 样例 #1

### 样例输入 #1

```
4 2
1 3
4 3
3 3
1 2
1 3
2 3
5 2
1 2
3 5
999 0
0
```

### 样例输出 #1

```
1
0
2
998
```

## 提示

#### 数据规模与约定

对于 $100\%$ 的数据，保证 $1 \le n < 1000$ 。

# 思路：

+ 这题明显也是有关于查询一个集合中有多少个元素的题目，我们考虑使用并查集解题，由于n的数据非常小，1000以内，所以我们直接开1005的数组作为fa数组即可
+ 我们可以将相互通路的城镇合并到一个集合中，由于我们要计算在没有和任何城镇相互通路的城镇，也就是这个集合之外的元素个数，我们可以计算所有元素的父节点是本身的元素的个数==result==，且==result-1==就是我们要求的答案，因为互相通路的城镇当中，还有那个根节点的父节点是它本身，所以说要用==result减去1，是我们集合之外的元素的个数==
+ 在解决上述问题后，我们的代码就非常简单了



```cpp
#include<cstring>
#include<iostream>
using namespace std;
int fa[1005];
int find(int x) {
	if (fa[x] == x) return x;
	return fa[x] = find(fa[x]);
}
void unoinNode(int x, int y) {
	fa[find(x)] = find(y);
}

int n, m;
int a, b;
int main()
{
	while (1) {
		cin >> n;
		if (n == 0) break;
		cin >> m;
		//有n个城镇，m条道路
		for (int i = 1; i <= n; i++) fa[i] = i;
		while (m--) {
			cin >> a >> b;
			unoinNode(a, b);
		}
		int ans = 0;
        //计算父节点是它本身的元素的个数
		for (int i = 1; i <= n; i++) {
			if (fa[i] == i) ans++;
		}
        //用这个个数-1，就是我们每一轮的答案
		cout << ans - 1 << endl;
		memset(fa, 0, sizeof(fa));
	}
	return 0;
}
```

