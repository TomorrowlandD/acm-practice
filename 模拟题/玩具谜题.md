# [NOIP2016 提高组] 玩具谜题

[P1563 [NOIP2016 提高组\] 玩具谜题 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1563)

## 题目背景

NOIP2016 提高组 D1T1

## 题目描述

小南有一套可爱的玩具小人，它们各有不同的职业。

有一天，这些玩具小人把小南的眼镜藏了起来。小南发现玩具小人们围成了一个圈，它们有的面朝圈内，有的面朝圈外。如下图：

![](https://cdn.luogu.com.cn/upload/image_hosting/0u7em9pi.png) 

这时 singer 告诉小南一个谜题：“眼镜藏在我左数第 $3$ 个玩具小人的右数第 $1$ 个玩具小人的左数第 $2$ 个玩具小人那里。”

小南发现，这个谜题中玩具小人的朝向非常关键，因为朝内和朝外的玩具小人的左右方向是相反的：面朝圈内的玩具小人，它的左边是顺时针方向，右边是逆时针方向；而面向圈外的玩具小人，它的左边是逆时针方向，右边是顺时针方向。

小南一边艰难地辨认着玩具小人，一边数着:

singer 朝内，左数第 $3$ 个是 archer。

archer 朝外，右数第 $1$ 个是 thinker。

thinker 朝外，左数第 $2$ 个是 writer。

所以眼镜藏在 writer 这里！

虽然成功找回了眼镜，但小南并没有放心。如果下次有更多的玩具小人藏他的眼镜，或是谜题的长度更长，他可能就无法找到眼镜了。所以小南希望你写程序帮他解决类似的谜题。这样的谜題具体可以描述为：

有 $n$ 个玩具小人围成一圈，已知它们的职业和朝向。现在第 $1$ 个玩具小人告诉小南一个包含 $m$ 条指令的谜題，其中第 $z$ 条指令形如“向左数/右数第 $s$ 个玩具小人”。你需要输出依次数完这些指令后，到达的玩具小人的职业。

## 输入格式

输入的第一行包含两个正整数 $n,m$，表示玩具小人的个数和指令的条数。

接下来 $n$ 行，每行包含一个整数和一个字符串，以逆时针为顺序给出每个玩具小人的朝向和职业。其中 $0$ 表示朝向圈内，$1$ 表示朝向圈外。保证不会出现其他的数。字符串长度不超过 $10$ 且仅由英文字母构成，字符串不为空，并且字符串两两不同。整数和字符串之间用一个空格隔开。

接下来 $m$ 行，其中第 $i$ 行包含两个整数 $a_i,s_i$，表示第 $i$ 条指令。若 $a_i=0$，表示向左数 $s_i$ 个人；若 $a_i=1$，表示向右数 $s_i$ 个人。 保证 $a_i$ 不会出现其他的数，$1 \le s_i < n$。

## 输出格式

输出一个字符串，表示从第一个读入的小人开始，依次数完 $m$ 条指令后到达的小人的职业。

## 样例 #1

### 样例输入 #1

```
7 3
0 singer
0 reader
0 mengbier 
1 thinker
1 archer
0 writer
1 mogician 
0 3
1 1
0 2
```

### 样例输出 #1

```
writer
```

## 样例 #2

### 样例输入 #2

```
10 10
1 C
0 r
0 P
1 d
1 e
1 m
1 t
1 y
1 u
0 V
1 7
1 1
1 4
0 5
0 3
0 1
1 6
1 2
0 8
0 4
```

### 样例输出 #2

```
y
```

## 提示

**样例 1 说明**

这组数据就是【题目描述】中提到的例子。


**子任务**

子任务会给出部分测试数据的特点。如果你在解决题目中遇到了困难，可以尝试只解决一部分测试数据。

每个测试点的数据规模及特点如下表:

![](https://cdn.luogu.com.cn/upload/image_hosting/7su06u3r.png)

其中一些简写的列意义如下:

- 全朝内：若为 $\surd$，表示该测试点保证所有的玩具小人都朝向圈内；

- 全左数：若为 $\surd$，表示该测试点保证所有的指令都向左数，即对任意的 $1\leq z\leq m, a_i=0$；

- $s=1$：若为 $\surd$，表示该测试点保证所有的指令都只数 $1$ 个，即对任意的 $1\leq z\leq m,s_i=1$；

职业长度为 $1$：若为 $\surd$，表示该测试点保证所有玩具小人的职业一定是一个长度为 $1$ 的字符串。





### 思路：

  这题题目叙述特别长！我们应该如何去思考呢？——首先，我们可以通读题干，发现题目大致只分为了四种情况：

1. 当前这个人面朝内，向左数若干个人
2. 当前这个人面朝内，向右数若干个人
3. 当前这个人面朝外，向左数若干个人
4. 当前这个人面朝内，向右数若干个人

其实我们认真思考一下，四种情况可以演变为两种情况！——1、4为一组，2、3为一组。当它们朝向不同并且向左数和向右数相反时，它们所达到的效果是一样的！

### 枚举所有情况

经过上面的分析，我们其实可以直接枚举完当前所有的情况，不过我们还有一个难题，就是如何构成一个环呢？？————在数组中，我们想在物理意义上构成一个环，我们可以采取取模运算！，这样可以使得我们的数组在

物理意义上看起来类似环形！这样我们就可以枚举所有情况了，不过在此之前，我们还得计算一下数学关系,假设当前这个人处于now位置：

1. 当人物面朝内时，向左数y个人，得到的结果应该是now = (now + n - y) % n;
2. 当人物面朝内时，向右数y个人，得到的结果应该是now = (now + y) % n;

这个数学关系并不是太难想明白，我们只需要在草稿纸上多画图模拟一下就可以得出数学关系，那么我们可以推出以下代码：

```cpp
	int now = 0; // 当前所在位置  
	while (m--) {
		cin >> x >> y; // x 为方向（0 表示左，1 表示右），y 为步数  

		// 判断当前人物的朝向，并据此移动  
		if (a[now].num == 0) { // 面朝圈内  
			if (x == 0) { // 左数（顺时针）  
				now = (now + n - y) % n;
			}
			else { // 右数（逆时针）  
				now = (now + y) % n;
			}
		}
		else { // 面朝圈外  
			if (x == 0) { // 左数（逆时针）  
				now = (now + y) % n;
			}
			else { // 右数（顺时针）  
				now = (now + n - y) % n;
			}
		}
	}
	cout << a[now].name << endl; // 输出最终所在位置的人物名字  
```

### 程序最终的AC代码如下：

```cpp
#include <iostream>  
#include <string>  
using namespace std;

const int N = 1e6 + 10;
struct person {
	int num; // 0 表示面朝圈内，1 表示面朝圈外  
	string name;
} a[N];

int n, m, x, y;

int main() {
	cin >> n >> m;
	for (int i = 0; i < n; i++) {
		cin >> a[i].num >> a[i].name;
	}

	int now = 0; // 当前所在位置  
	while (m--) {
		cin >> x >> y; // x 为方向（0 表示左，1 表示右），y 为步数  

		// 判断当前人物的朝向，并据此移动  
		if (a[now].num == 0) { // 面朝圈内  
			if (x == 0) { // 左数（顺时针）  
				now = (now + n - y) % n;
			}
			else { // 右数（逆时针）  
				now = (now + y) % n;
			}
		}
		else { // 面朝圈外  
			if (x == 0) { // 左数（逆时针）  
				now = (now + y) % n;
			}
			else { // 右数（顺时针）  
				now = (now + n - y) % n;
			}
		}
	}
	cout << a[now].name << endl; // 输出最终所在位置的人物名字  
	return 0;
}
```

