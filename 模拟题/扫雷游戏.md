# [NOIP2015 普及组] 扫雷游戏

[P2670 [NOIP2015 普及组\] 扫雷游戏 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P2670)

## 题目背景

NOIP2015 普及组 T2

## 题目描述

扫雷游戏是一款十分经典的单机小游戏。在 $n$ 行 $m$ 列的雷区中有一些格子含有地雷（称之为地雷格），其他格子不含地雷（称之为非地雷格）。玩家翻开一个非地雷格时，该格将会出现一个数字——提示周围格子中有多少个是地雷格。游戏的目标是在不翻出任何地雷格的条件下，找出所有的非地雷格。

现在给出 $n$ 行 $m$ 列的雷区中的地雷分布，要求计算出每个非地雷格周围的地雷格数。

注：一个格子的周围格子包括其上、下、左、右、左上、右上、左下、右下八个方向上与之直接相邻的格子。

## 输入格式

第一行是用一个空格隔开的两个整数 $n$ 和 $m$，分别表示雷区的行数和列数。

接下来 $n$ 行，每行 $m$ 个字符，描述了雷区中的地雷分布情况。字符 $\texttt{*}$ 表示相应格子是地雷格，字符 $\texttt{?}$ 表示相应格子是非地雷格。相邻字符之间无分隔符。

## 输出格式

输出文件包含 $n$ 行，每行 $m$ 个字符，描述整个雷区。用 $\texttt{*}$ 表示地雷格，用周围的地雷个数表示非地雷格。相邻字符之间无分隔符。

## 样例 #1

### 样例输入 #1

```
3 3
*??
???
?*?
```

### 样例输出 #1

```
*10
221
1*1
```

## 样例 #2

### 样例输入 #2

```
2 3
?*?
*??
```

### 样例输出 #2

```
2*1
*21
```

## 提示

对于 $100\%$的数据，$1≤n≤100, 1≤m≤100$。





### 我们有什么思路？

这题我们可以采用什么样的方法呢？我们可以直接采用二维数组来储存这个雷区（二维数组全都初始化为0，并且可以开大一点，以防止数组越界），然后再一个一个输入，如果碰到这个点是`*`号的话，就可以将这个点赋值为1，否则不变（为0）

然后，我们选择遍历这个二维数组，如果碰到为1的元素，直接赋值为`*`即可，否则，我们就遍历它周围的八个元素，并且全部加起来，看看他周围有多少个雷，并输出这个数字，这道题目就完成啦！

### 完整AC代码如下：


------------

```cpp
#include<cstring>
#include<iostream>
using namespace std;
bool a[105][105];
int main()
{
	int n, m;
	cin >> n >> m;
	char temp;
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			cin >> temp;
			if (temp == '*') a[i][j] = 1;
		}
	}
	//输出数组
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			if (a[i][j] == 1) cout << "*";
			else cout << a[i - 1][j] + a[i + 1][j] + a[i][j - 1] + a[i][j + 1] +
                a[i - 1][j - 1] + a[i - 1][j + 1]+ a[i + 1][j - 1] + a[i + 1][j + 1];
		}
		cout << endl;
	}
	return 0;
}

```

