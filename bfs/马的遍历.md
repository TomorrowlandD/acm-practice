# 马的遍历

[P1443 马的遍历 - 洛谷 | 计算机科学教育新生态](https://www.luogu.com.cn/problem/P1443)

## 题目描述

有一个 $n \times m$ 的棋盘，在某个点 $(x, y)$ 上有一个马，要求你计算出马到达棋盘上任意一个点最少要走几步。

## 输入格式

输入只有一行四个整数，分别为 $n, m, x, y$。

## 输出格式

一个 $n \times m$ 的矩阵，代表马到达某个点最少要走几步（不能到达则输出 $-1$）。

## 样例 #1

### 样例输入 #1

```
3 3 1 1
```

### 样例输出 #1

```
0    3    2    
3    -1   1    
2    1    4
```

## 提示

### 数据规模与约定

对于全部的测试点，保证 $1 \leq x \leq n \leq 400$，$1 \leq y \leq m \leq 400$。





## 思路：

bfs模板题，直接套用板子即可解决

```cpp
#include<iostream>
#include<queue>
#include<cstring>
#include<algorithm>
using namespace std;
const int N = 405;
int g[N][N];
int dist[N][N];
int n, m, x, y;
int dx[8] = { -1,-2,-2,-1,1,2,2,1 };
 int dy[8] = { 2,1,-1,-2,2,1,-1,-2 };
void bfs(int x, int y)
{
	memset(dist, -1, sizeof(dist));
	queue<pair<int, int> > q;
	q.push({ x,y });
	g[x][y] = 1;
	dist[x][y] = 0;
	while (q.size()) {
		auto u = q.front();
		q.pop();
		int xx = u.first;
		int yy = u.second;
		for (int i = 0; i < 8; i++) {
			int a = xx + dx[i];
			int b = yy + dy[i];
			if (a<1 || a>n || b<1 || b>m) continue;
			if (g[a][b]) continue;
			//计算距离
			dist[a][b] = dist[xx][yy] + 1;
			//判重数组
			g[a][b] = 1;
			//当前坐标入队
			q.push({ a,b });
		}
	}
}
int main()
{
	cin >> n >> m >> x >> y;
	bfs(x, y);
	for (int i = 1; i <= n; i++) {
		for (int j = 1; j <= m; j++) {
			printf("%5d", dist[i][j]);
		}
		printf("\n");
	}
	return 0;
}
```

