# 走迷宫

给定一个n×m 的二维整数数组，用来表示一个迷宫，数组中只包含 0 或 1，其中 0 表示可以走的路，1 表示不可通过的墙壁。

最初，有一个人位于左上角 (1,1)处，已知该人每次可以向上、下、左、右任意一个方向移动一个位置。

请问，该人从左上角移动至右下角 (n,m) 处，至少需要移动多少次。

数据保证 (1,1)处和 (n,m)处的数字为 0，且一定至少存在一条通路。

#### 输入格式

第一行包含两个整数 n 和 m。

接下来 n 行，每行包含 m 个整数（0 或 1），表示完整的二维数组迷宫。

#### 输出格式

输出一个整数，表示从左上角移动至右下角的最少移动次数。

#### 数据范围

1<=n,m<=100

#### 输入样例：

```
5 5
0 1 0 0 0
0 1 0 1 0
0 0 0 0 0
0 1 1 1 0
0 0 0 1 0
```

#### 输出样例：

```
8
```





[AcWing 844. 走迷宫 - AcWing](https://www.acwing.com/activity/content/problem/content/907/)

 ## 代码(输出路径)：

```cpp
#include<iostream>
#include<queue>
#include<vector>
using namespace std;
const int N = 55;
struct node {
	int x, y;
};
node pre[N][N];
int dx[4] = {-1,0,1,0};
int dy[4] = { 0,1,0,-1 };
int g[N][N];
int n;
void bfs(int x, int y)
{
	queue<node> q;
	q.push({ x,y });
	g[x][y] = 1;
	while (q.size()) {
		auto u = q.front(); q.pop();
		for (int i = 0; i < 4; i++) {
			int a = u.x + dx[i];
			int b = u.y + dy[i];
			if (a < 0 || a >= n || b<0 || b>n) continue;
			if (g[a][b]) continue;
			g[a][b] = 1;
			pre[a][b] = u;
			q.push({ a,b });
		}
	}
}
//递归输出路径
void print(int x,int y)
{
	if (x == 0 && y == 0) return;
	node p = pre[x][y];
	print(p.x, p.y);
	cout << x << " " << y << endl;
}
int main()
{
	cin >> n;
	for (int i = 0; i < n; i++) {
		for (int j = 0; j < n; j++) {
			cin >> g[i][j];
		}
	}
	//广搜
	bfs(0, 0);
	cout << 0 << " " << 0 << endl;
	print(n - 1, n - 1);
	return 0;
}
```



上面的代码需要将到达迷宫的路径输出出来，而下列这段代码则是输出了经过最短路径的步数

## 代码(输出操作步数)

```cpp
#include<iostream>
#include<queue>
using namespace std;
const int N = 110;
int n, m, g[N][N];
struct node { int x, y; };
int dist[N][N];
int ans;
int dx[4] = { -1,0,1,0 };
int dy[4] = { 0,1,0,-1 };
void bfs(int x, int y) {
  queue<node> q;
  q.push({ x,y });
  g[x][y] = 1;
  dist[x][y] = 0;
  while (q.size()) {
    auto u = q.front(); q.pop();
    for (int i = 0; i < 4; i++) {
      int a = u.x + dx[i];
      int b = u.y + dy[i];
      if (g[a][b]) continue;
      if (a < 1 || a > n || b < 1 || b > m) continue;
      g[a][b] = 1;
      q.push({ a,b });
      dist[a][b] = dist[u.x][u.y] + 1;
      if (a == n && b == m) {
        ans = dist[a][b];
        return;
      }
    }
  }
}
int main()
{
  cin >> n >> m;
  for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= m; j++) {
      cin >> g[i][j];
    }
  }
  bfs(1, 1);
  cout << ans;
  return 0;
}
```









## 代码：

抓走那头牛：

 ```cpp
 #include<iostream>
 #include<queue>
 using namespace std;
 const int N = 1e5 + 5;
 int dis[N];
 int t, x, y;
 void bfs()
 {
 	queue<int> q; q.push(x);
 	memset(dis,-1,sizeof(dis)); dis[x] = 0;
 	while (q.size()) {
 		int x = q.front(); q.pop();
 		if (x + 1 < N && dis[x + 1] == -1) { dis[x + 1] = dis[x] + 1; q.push(x + 1); }
 		if (x - 1 > 0 && dis[x - 1] == -1) { dis[x - 1] = dis[x] + 1; q.push(x - 1); }
 		if (x * 2 < N && dis[2 * x] == -1) { dis[2 * x] = dis[x] + 1; q.push(2 * x); }
 		if (x == y) { cout << dis[y] << endl; return; }
 	}
 }
 int main()
 {
 	cin >> t;
 	while (t--) {
 		cin >> x >> y;
 		bfs();
 	}
 	return 0;
 }
 ```

