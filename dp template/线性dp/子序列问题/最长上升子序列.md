## 最长上升子序列

https://www.acwing.com/problem/content/897/

# 题目叙述：

给定一个无序的整数数组，找出其中最长上升子序列（LIS）的长度。

### 输入：

```cpp
[5,7,1,9,4,6,2,8,3]
```

### 输出

```cpp
4
```

### 解释

+ 最长上升子序列是[1，4，6，8]，其长度为4。

# 动态规划的设计：

+ 首先，我们对数组进行下标的映射，我们从下标为1的位置开始计数

+ 并且，我们计算以每一个元素a【i】为结尾的最长上升子序列的长度f【i】。

![img](https://img2024.cnblogs.com/blog/3476421/202408/3476421-20240819150041928-427480902.png)

+ 由上面这张图我们可知，最长的上升子序列可以由前面的状态推出，因此我们可以考虑使用动态规划算法

## 状态变量f[i]的含义：

+ `f[i]代表以a[i]为结尾的最长上升子序列长度`
+ 初始条件为==f[i]=1==

## 递推公式：

+ 我们需要一个j指针，每次遍历到a【i】时，我们都需要j指针，从1开始移动，移动到i-1的位置，如果发现a[i]>a[j]，那么我们就更新f【i】的值，不过还得判断一下f【j】+1与f【i】的大小关系。

```cpp
for(int i=2;i<=n;i++){
    for(int j=1;j<i;j++){
        if(a[i]>a[j]) f[i]=max(f[i],f[j]+1);
    }
    //ans为最终的最大上升子序列的长度
    ans=max(ans,f[i]);
}
```

## 递推式满足的条件

+ 由小推大（最优子结构）
+ 由过去推现在（无后效性）

## 疑问：

+ f[i]记录以a[i]为开头的最长上升子序列可以吗？——可以，不过遍历顺序就是从后向前遍历，递推式也需要改变改变，这里读者可以自行推理！
+ f[i]记录前i个数的最长上升子序列的长度，可以吗？——不可以，举例两个就可以发现明显错误的反例，因此不成立。

![img](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250122222702846-573075171.png)

# 代码实现：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long 
int a[1005],dp[1005];
signed main()
{
    int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i],dp[i]=1;
    int ans=1;
    for(int i=2;i<=n;i++){
        for(int j=1;j<i;j++){
            if(a[j]<a[i]) dp[i]=max(dp[i],dp[j]+1);
        }
        ans = max(ans, dp[i]);
    }
    cout<<ans;
    return 0;
}
```

