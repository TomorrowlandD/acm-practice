        # 01背包

### 问题：

一个容量为m公斤的背包，现在有n种物品，`每种物品只有一件`，他们的重量分别为W<sub>i</sub>(1<=i<=n)，它们的价值分别为C<sub>i</sub> ，求能放入背包的最大价值。

### 输入：

第一行：两个整数，n（物品数量，n<51）和m（背包容量，m＜201），

第2..n+1行：每行两个整数Wi，Ci，表示每个物品的重量和价值。

### 输出：
一 个数，表示最大价值。

### 样例输入：

```cpp
3 6
3 5
2 3
4 6
```

样例输出：

```cpp
9
```

## 解决背包问题的思路：

1. 确定状态变量（函数）
2. 确定状态转移方程（递推关系）
3. 确定边界条件

最大价值是`物品数目i`和`背包容量j`的函数

设`f[i][j]`表示`前i件物品`放入`容量为j的背包`的`最大价值`

最终的最大价值就是物品数目i从0增长到n，背包容量j从0增长到m时的`f[n][m]`值。

![](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250126131235288-1909356991.png)
![](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250126131309224-989045911.png)
![](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250126132206634-1414305827.png)
![](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250126132735023-269617566.png)
![](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250126132944229-35197934.png)

### 不优化空间的代码：

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(j<w[i]) f[i][j]=f[i-1][j];
        else f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+c[i]);
    }
}
```

### 优化空间后的代码：

```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=1;j--){
        if(j<w[i]) f[j]=f[j];
        else f[j]=max(f[j],f[j-w[i]]+c[i]);
    }
}
```

### 最终优化版代码：

```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=w[i];j--){
        f[j]=max(f[j],f[j-w[i]]+c[i]);
    }
}
```

