链接：https://ac.nowcoder.com/acm/problem/19158
来源：牛客网

终于Alice走出了大魔王的陷阱，可是现在傻傻的她忘了带武器了，这可如何是好???这个时候，一个神秘老人走到她面前答应无偿给她武器，但老人有个条件，需要将所选武器分别放在天平的两端，若天平平衡则可以将天平上的所有武器拿走，还好这个天平锈迹斑斑，只要两端重量相差小于等于m就会保持平衡，Alice傻傻的认为越重的武器越好，求Alice最多能拿走的武器总重量。（不限操作次数）

## 输入描述:

```
第一行2个整数 n, m;
第二行n个整数x，分别表示n件武器的重量。
1 <= n <= 100; 0 <= m <= 100; 1 <= x <= 100;
```

## 输出描述:

```
一个整数，表示Alice最多能拿走的武器总重量。
```

​                            示例1                        

## 输入1

```
5 4
1 5 61 65 100
```

## 输出1

```
132
```

## 说明1

```
可以称两次，第1次：(1 ; 5),第二次(61 ; 65)。
```

​                            示例2                        

## 输入2

```
5 0
10 20 30 40 100
```

## 输出2

```
200
```

## 说明2

```
称一次，(10,20,30,40 ; 100)。
```

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=105*100;
//设f[i][j]为:前i件物品,平衡度为j时所能攫取的最大收益
//则ans=f[i][j]的最大值(0<=j<=m)
int a[N],f[105][N];
int main()
{
    int n,m;
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    //初始化f数组,初始全都设为最小值.
    memset(f,-0x3f,sizeof(f));
    //第0件物品，平衡度为0时，攫取的最大价值为0.
    f[0][0]=0;
    //开始递推
    for(int i=1;i<=n;i++){
        for(int j=0;j<=N;j++){
            //不处理第i件物品
            f[i][j]=f[i-1][j];
            //第i件物品让平衡度减小了a[i],可能会有负数，故加绝对值
            f[i][j]=max(f[i][j],f[i-1][abs(j-a[i])]+a[i]);
            //第i件物品让平衡度增大了a[i]
            f[i][j]=max(f[i][j],f[i-1][j+a[i]]+a[i]);
        }
    }
    int ans=0;
    //打擂台，取最小的一个
    for(int i=0;i<=m;i++) ans=max(ans,f[n][i]);
    cout<<ans;
    return 0;
}
```



