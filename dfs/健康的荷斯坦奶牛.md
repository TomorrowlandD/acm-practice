# [USACO2.1] 健康的荷斯坦奶牛 Healthy Holsteins

## 题目描述

农民 John 以拥有世界上最健康的奶牛为傲。他知道每种饲料中所包含的牛所需的最低的维他命量是多少。请你帮助农夫喂养他的牛，以保持它们的健康，使喂给牛的饲料的种数最少。

给出牛所需的最低的维他命量，输出喂给牛需要哪些种类的饲料，且所需的饲料剂量最少。

维他命量以整数表示，每种饲料最多只能对牛使用一次，数据保证存在解。

## 输入格式

第一行一个整数 $v$，表示需要的维他命的种类数。  
第二行 $v$ 个整数，表示牛每天需要的每种维他命的最小量。

第三行一个整数 $g$，表示可用来喂牛的饲料的种数。   
下面 $g$ 行，第 $n$ 行表示编号为 $n$ 饲料包含的各种维他命的量的多少。

## 输出格式

输出文件只有一行，包括牛必需的最小的饲料种数 $p$；后面有 $p$ 个数，表示所选择的饲料编号（按从小到大排列）。

如果有多个解，输出饲料序号最小的（即字典序最小）。

## 样例 #1

### 样例输入 #1

```
4
100 200 300 400
3
50  50  50  50
200 300 200 300
900 150 389 399
```

### 样例输出 #1

```
2 1 3
```

## 提示

【数据范围】  
对于 $100\%$ 的数据，$1\le v \le 25$，$1\le g \le 15$。  
输入的所有整数在 $[1,1000]$ 范围内。

USACO 2.1

翻译来自NOCOW



## 思路：

这道题算是很简单的dfs，都不需要剪枝。

首先定义一个搜索函数，函数传递的变量为t和s,t表示搜索到了第t种饲料，s表示目前选的饲料的总数。

然后确定搜索的边界，也就是t>饲料的种数，然后判断每次选的那些饲料中的维生素之和是不是都大于等于牛每天需要的每种维他命的最小量（可以用个函数写）。如果是，就判断选的饲料的总数小于以前的最优解（类似于打擂台的那种操作），如果小于，那么当前最优解就要被替换掉，而最优解的一个数组也要被替换掉。最后return即可。

接着开始写函数的主体部分。首先我们选第t种饲料，那么s就要加一，并且我们还要把t存在一个数组当中（想想为什么要存）。然后就可以调用函数，即search(t+1,s+1); 调完函数后，记得要回溯.把t从数组中拿走。接下来我们不选第t种饲料，这样做很简单，直接搜索一步：search(t+1,s); 就行了。

最后输出解即可。

思路就这么多。

## 代码：

```cpp
#include<iostream>
using namespace std;
int n, m;
int a[1005];	//表示每头牛需要第i种维生素的数目
int bh[1005];	//表示每次选取的编号
int ans[1005];	//用来存取答案
int b[1005][1005];	//表示第i种饲料含有第j种维生素的数目
int mn = 1e9;
//选择了x个饲料，检查所选取的x种饲料中，每种维生素的数目是否均大于所需维生素的数目
bool check(int x) {
	for (int i = 1; i <= n; i++) {
		int sum = 0;
		for (int j = 1; j <= x; j++) {
			sum += b[bh[j]][i];
		}
		if (sum < a[i]) return false;
	}
	return true;
}
void dfs(int index, int cnt) {
	//递归终止条件为遍历完最后一种饲料了
	if (index > m) {
		//必须满足维生素足够
		if (check(cnt)) {
			//更新答案
			if (cnt < mn) {
				mn = cnt;
				for (int i = 1; i <= mn; i++) ans[i] = bh[i];
			}
		}
		return;
	}
	//将当前下标放入编号数组中，然后递归
	bh[cnt + 1] = index;
	//这是选择第index个饲料的时候
	dfs(index + 1, cnt + 1);
	//这是不选择第index个饲料的时候
	dfs(index + 1, cnt);
}
int main()
{
	cin >> n;
	for (int i = 1; i <= n; i++) cin >> a[i];
	cin >> m;
	for (int i = 1; i <= m; i++) {
		for (int j = 1; j <= n; j++) {
			cin >> b[i][j];
		}
	}
	dfs(1, 0);
	cout << mn << " ";
	for (int i = 1; i <= mn; i++) cout << ans[i] << " ";
	return 0;
}
```

