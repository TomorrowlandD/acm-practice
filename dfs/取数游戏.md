# 取数游戏

https://www.luogu.com.cn/problem/P1123

## 题目描述

一个 $N\times M$ 的由非负整数构成的数字矩阵，你需要在其中取出若干个数字，使得取出的任意两个数字不相邻（若一个数字在另外一个数字相邻 $8$ 个格子中的一个即认为这两个数字相邻），求取出数字和最大是多少。

## 输入格式

第一行有一个正整数 $T$，表示了有 $T$ 组数据。

对于每一组数据，第一行有两个正整数 $N$ 和 $M$，表示了数字矩阵为 $N$ 行 $M$ 列。

接下来 $N$ 行，每行 $M$ 个非负整数，描述了这个数字矩阵。

## 输出格式

共 $T$ 行，每行一个非负整数，输出所求得的答案。

## 样例 #1

### 样例输入 #1

```
3
4 4
67 75 63 10
29 29 92 14
21 68 71 56
8 67 91 25
2 3
87 70 85
10 3 17
3 3
1 1 1
1 99 1
1 1 1
```

### 样例输出 #1

```
271
172
99
```

## 提示

### 样例解释

对于第一组数据，取数方式如下：

$$\begin{matrix}
[67] & 75 & 63 & 10 \\
29 & 29 & [92] & 14 \\
[21] & 68 & 71 & 56 \\
8 & 67 & [91] & 25 \\
\end{matrix}$$


### 数据范围及约定

- 对于$20\%$的数据，$1\le N, M \le 3$；
- 对于$40\%$的数据，$1\le N, M\le 4$；
- 对于$60\%$的数据，$1\le N, M\le 5$；
- 对于$100\%$的数据，$1\le N, M\le 6$，$1\le T\le 20$。





## 思路：

### **再考虑每个数的状态。**

显然，对于一个数，有取与不取两种状态，状态改变取决于周围取数的变化。我们用 **mark[ i ][ j ]** 记录点 **( i , j )** 附近有几个数，若 **mark[ i ][ j ] ! = 0** 就代表不能取这个数。



## 代码：

```cpp
#include<iostream>
#include<cstring>
using namespace std;
int g[10][10];
int vis[10][10];
int n, m;
int mx = -1, sum = 0;
int dx[]{ -1,-1,0,1,1,1,0,-1 };
int dy[]{ 0,1,1,1,0,-1,-1,-1 };
void dfs(int x, int y) {
	//这里的y错了，不应该是y，而是1,从下一行的第一个数开始搜
	if (y > m) { dfs(x + 1, 1); return; }
	//这里就更新答案了。
	if (x > n) { mx=max(mx,sum); return; }
	// 不取这个数
	dfs(x, y + 1);
	//选取现在这个数,但是得保证这个点从未被标记过。
	if (!vis[x][y]) {
		sum += g[x][y];
		for (int i = 0; i < 8; i++) vis[x + dx[i]][y + dy[i]]++;
		dfs(x, y + 1);
		sum -= g[x][y];
		for (int i = 0; i < 8; i++) vis[x + dx[i]][y + dy[i]]--;
	}
}
int main()
{
	int t; cin >> t;
	while (t--) {
		memset(vis, 0, sizeof(vis));
		memset(g, 0, sizeof(g));
		cin >> n >> m;
		mx = -1; sum = 0;
		for (int i = 1; i <= n; i++) {
			for (int j = 1; j <= m; j++) {
				cin >> g[i][j];
			}
		}
		//从（1，1）开始爆搜
		dfs(1, 1);
		cout << mx << endl;
	}
	return 0;
}
```

