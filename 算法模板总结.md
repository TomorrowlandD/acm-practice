# 基础算法

### 1.整数二分模板

利用库函数：

```cpp
lower_bound(a+1,a+1+n,x) //找到a数组中第一个>=x的位置,a有n个元素,从1-n
upper_bound(a+1,a+1+n,x) //找到a数组中第一个>x的位置
```

首先：满足条件的区域称为可行区

可行区的指针最后一定指向答案

1.查找最后一个<=q的数的下标（可行区在左侧）

```cpp
int find(int q){
    int l=0,r=n+1;		//开区间
    while(l+1<r){	//当l+1=r时，循环结束
        int mid=l+r>>1;
        //左指针l只允许在可行区域内移动
        if(a[mid]<=q) l=mid;
        else r=mid;	//右指针r只允许在不可行区域内移动
    }
    return l;
}
```

2.查找第一个>=q的数的下标（可行区在右侧）

```cpp
int find (int q){
    int l=0,r=n+1;
    while(l+1<r){
        int mid=l+r>>1;
        if(a[mid]>=q)  r=mid;	//让右指针左移
        else l=mid;
    }
    return r;
}
```

### 2.浮点数二分模板

题目叙述：求一个浮点数（-10000≤y≤10000)的三次方根

```cpp
double find(double y)
{
    //求开区间
    double left=-100,right=100;
    //当left和right无限接近时结束循环,这里的1e-5可改为更小,看精度需求即可
    while(right-left>1e-5){
        double mid=(right-left)/2;
        //如果mid^3≤y，证明当前的mid满足条件，我们还需要查找更大的范围，所以要让left右移看看更大的范围中还有没有mid满
        //足条件的，如果没有，现在的left就是答案。
        if(mid*mid*mid<=y) left=mid;//这也就是最大化问题，我们会移动left指针，找到满足题意的最大值
        else right=mid;
   }
    return left;
}
```

### 3.二分答案：

![img](https://img2024.cnblogs.com/blog/3476421/202501/3476421-20250104202205330-736162527.png)

1.最大化答案:（求X<sub>max</sub>）

x在可行区，check为真，l右移

```cpp
bool check(int x){
    ...... //计算y的过程
    return y<=c	//y随着x增大而递增
    return y>=c	//y随着x增大而递减
}
int find(){
    int l=下界-1，r=上界+1;
    while(l+1<r){
        int mid=l+r>>1;
        if(check(mid)) l=mid;
        else r=mid;
    }
    return l;
}
```

2.最小化答案:（求X<sub>min</sub>）

x在可行区，则check为真，r左移

```cpp
bool check(int x){
    ...... //计算y的过程
    return y>=c	//y随着x增大而递增
    return y<=c	//y随着x增大而递减
}
int find(){
    int l=下界-1，r=上界+1;
    while(l+1<r){
        int mid=l+r>>1;
        if(check(mid)) r=mid;
        else l=mid;
    }
    return r;
}
```

如何计算y呢？

+ 计数型
+ 求和型
+ 是否型

如何确定板子？   答：画出图像确定我们需要使用的板子

### 4.一维前缀和

前缀和可以用于快速计算一个序列的区间和，也有很多问题里不是直接用前缀和，而是使用了前缀和的思想。

```cpp
预处理：s[i]=s[i-1]+a[i];
求(l,r)区间和:ans=s[r]-s[l-1];
```

### 5.二维前缀和

```cpp
计算矩阵的前缀和：s[x][y]=s[x-1][y]+s[x][y-1]+s[x-1][y-1]+a[x][y];
以(x1,y1)为左上角，(x2,y2)为右下角的子矩阵的和为：
sum=s[x2][y2]-s[x1-1][y2]-s[x2][y2-1]+s[x1-1][y1-1];
```

应用：

```cpp
int s[1010][1010];
int n,m,q;	//矩阵n行m列，有q次查询
int main(){
	cin>>n>>m>>q;
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) cin>>s[i][j];
	}
	//做二维前缀和
	for(int i=1;i<=n;i++){
		for(int j=1;j<=m;j++) s[i][j]+=s[i-1][j]+s[i][j-1]-s[i-1][j-1];
	}
	//q次查询,每次查询左上角为(x1,y1),右下角为(x2,y2)的子矩阵的和
	while(q--){
		int x1,y1,x2,y2;
		cin>>x1>>y1>>x2>>y2;
		int ans=s[x2][y2]-s[x2][y2-1]-s[x1-1][y2]+s[x1-1][y1-1];
		cout<<ans<<"\n";
	}
}
```

### 6.一维差分:

差分是前缀和的逆运算，对于一个数组a，其差分数组b的每一项都是a[i]与前一项a[i-1] 的差

**注意：差分数组和原数组必须分开存放!!**

```cpp
给原数组中[l,r]区间每一个数加上c,那么只需对差分数组b的两个点做操作.  b[l]+=c,b[r+1]-=c;
```

应用：

```cpp
const int N=1e5+10;
int a[N],b[N];
int main(){
    int n,m;cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i],b[i]=a[i]-a[i-1];
    //m次区间操作,每次对[l,r]区间内加上c
    while(m--){
        int l,r,c;cin>>l>>r>>c;
        b[l]+=c;b[r+1]-=c;
    }
    //给差分数组还原成原数组，就完成了操作(做前缀和即可)
    for(int i=1;i<=n;i++) s[i]+=s[i-1];
    return 0;
}
```

### 7.ST表

![](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250212223009858-1434595697.png)

主要用于解决区间最大/最小值查询问题，主要运用倍增思想。可以实现0(nlogn)预处理,0(1)查询
1.预处理ST表：
倍增法递推，用两个等长的小区间拼凑成一个大区间。
`f[i][j]`表示以`i`为起点，2^j^为长度的区间中的最大值:
2.处理查询：
对查询区间[l,r]做分割，拼凑。区间长度的指数为：k=log2(r-l+1)。
区间[l,r]必然可以使用两个长度为2^k^的区间重叠拼凑
应用：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
//最大存储2^22，也就是10^6左右的区间 
int fmax[N][22],fmin[N][22];
int a[N],n,m;
void buildST()
{
    for(int i=1;i<=n;i++) fmax[i][0]=a[i],fmin[i][0]=a[i];
    // 预处理，外层循环枚举区间长度，内存循环枚举左端点
    for(int j=1;j<=20;j++){
        //循环条件为:右端点<=n,可利用数学关系算出右端点的表达式
        for(int i=1;i+(1<<j)-1<=n;i++){	
            //存区间最大值/最小值。
            fmax[i][j]=max(fmax[i][j-1],fmax[i+(1<<(j-1))][j-1]);
            fmin[i][j]=min(fmin[i][j-1],fmin[i+(1<<(j-1))][j-1]);
        } 
    }
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i];
    //构建ST表
    buildST();
    //查询区间最小值
    for(int i=1;i<=m;i++){
        int l,r;
        cin>>l>>r;
        int k=log2(r-l+1);
        cout<<max(fmax[l][k],fmax[r+1-(1<<k)][k])<<' '
            <<min(fmin[l][k],fmin[r+1-(1<<k)][k])<<'\n';
    }
    return 0;
}
```

### 8.快速幂

快速幂可以应用在任何具有结合律的运算中，例如：取模运算，矩阵乘法等等。

![](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250210212226007-142190606.png)

```cpp
//计算(a^n)%p的值
int quickpow(int a,int n,int p)
{
    int res=1;
    while(n){
        if(n&1) res=res*a%p;
        a=a*a%p;
        n>>=1;
    }
    return res;
}
```

### 9.高精度加法

```cpp
const int N=505;
int a[N],b[N],c[N];
int la,lb,lc;
void add(int a[],int b[],int c[]){ //a+b=c
  for(int i=1; i<=lc; i++){
    c[i]+=a[i]+b[i]; //求和
    c[i+1]+=c[i]/10; //进位
    c[i]%=10;        //存余
  }
  if(c[lc+1]) lc++;  //最高位
}
int main(){
  string sa,sb; cin>>sa>>sb;
  la=sa.size(),lb=sb.size(),lc=max(la,lb);
  for(int i=1; i<=la; i++) a[i]=sa[la-i]-'0';
  for(int i=1; i<=lb; i++) b[i]=sb[lb-i]-'0';
  add(a,b,c);
  for(int i=lc; i; i--) printf("%d",c[i]);
  return 0;
}
```

### 10.高精度减法

与高精度加法差不多，若A<B，先输出负号，再交换a，b即可

```cpp
const int N=10086+10;
int a[N],b[N],c[N];
int la,lb,lc;
bool cmp(int a[],int b[]){
    if(la!=lb) return la<lb;
    for(int i=1;i<=la;i++){
        if(a[i]!=b[i]) return la<lb;
    }
    return false;
}
void sub(int a[],int b[],int c[]){
    for(int i=1;i<=lc;i++){
        if(a[i]<b[i]) a[i+1]--,a[i]+=10;
        c[i]=a[i]-b[i];
    }
    while(!c[lc]&&lc>1) lc--;
}
int main()
{
    string sa,sb;cin>>sa>>sb;
    la=sa.size(),lb=sb.size(),lc=max(la,lb);
    for(int i=1;i<=la;i++) a[i]=sa[la-i]-'0';
    for(int i=1;i<=lb;i++) b[i]=sb[lb-i]-'0';
    if(cmp(a,b)) swap(a,b),cout<<"-";
    sub(a,b,c);
    for(int i=lc;i>=1;i--) cout<<c[i];
    return 0;
}
```

### 11.高精度乘法

乘法的关键在于：a的第i位乘以b的第j位，会在c的第`i+j-1`位获得价值。那么我们在c的第`i+j-1` 位先存着乘积即可。然后再做进位操作

```cpp 
const int N=4001;
int a[N],b[N],c[N];
int la,lb,lc;

void mul(int a[],int b[],int c[]){ //a*b=c
  for(int i=1;i<=la;i++)
    for(int j=1;j<=lb;j++)
      c[i+j-1]+=a[i]*b[j]; //存乘积
      
  for(int i=1;i<lc;i++){
    c[i+1]+=c[i]/10;  //存进位
    c[i]%=10;         //存余数
  }
  while(c[lc]==0&&lc>1) lc--; //去0  
}
int main(){
  char A[N],B[N];
  cin>>A>>B;
  la=strlen(A); lb=strlen(B); lc=la+lb;
  for(int i=1;i<=la;i++)a[i]=A[la-i]-'0';
  for(int i=1;i<=lb;i++)b[i]=B[lb-i]-'0';
  mul(a,b,c);
  for(int i=lc;i>=1;i--) cout<<c[i];
  return 0;
}
```

### 12.高精度除法

```cpp
const int N=5005;
int a[N],b,c[N];
int len;

void div(int a[],int b,int c[]){ //  a/b=c
  long long t=0;
  for(int i=len;i>=1;i--){
    t=t*10+a[i];  //被除数
    c[i]=t/b;     //存商
    t%=b;         //余数
  }
  while(c[len]==0&&len>1) len--; //去0  
}
int main(){        
  char A[N]; cin>>A>>b; len=strlen(A);
  for(int i=1;i<=len;i++) a[i]=A[len-i]-'0';
  div(a,b,c);
  for(int i=len;i;i--) cout<<c[i];  
  return 0;
}
```







# 背包

### 1.01背包问题

题意：有n件物品(不可分割)，每件物品的价值分别为:`c[i]`，重量为`w[i]`，背包容量为m.问最多可获取的价值为多少？
可用`f[i][j]`来表示背包前i件物品，背包容量为j时可获取的最大价值。答案即为：`f[n][m]`。
普通版本01背包：

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(j<w[i]) f[i][j]=f[i-1][j];
        else f[i][j]=max(f[i-1][j],f[i-1][j-w[i]]+c[i]);
    }
}
```

优化空间的01背包：
这里因为需要使用上一行的`f[i-1][j-w[i]]`来更新，所以得逆序循环。因为`f[j]`会先于`f[j-w[i]]`去更新，也就是说，用旧的`f[j-w[i]]`去更新`f[j]`，就相当于用上一行的`f[j-w[i]]`来更新`f[j]`。这里与完全背包有所不同。

```cpp
for(int i=1;i<=n;i++){
    for(int j=m;j>=w[i];j--){	//这里省略了j<w[i]的情况，因为那种情况答案不会发生变化，无需遍历。
        f[j]=max(f[j],f[j-w[i]]+c[i]);
    }
}
```

### 2.完全背包

一个容量为m公斤的背包。现有n种物品，每种物品有无限多件，它们的重量分别为wi(1≤i≤n)，它们的价值分别为Ci(1≤i≤n)。求能放入背包的最大价值。
因为j是顺序循环，`f[j-w[i]]`会先于`f[j]`更新。也就是用新值`f[j-w[i]]`来更新`f[j]`，相当于用第i行的`f[j-w[i]]`去更新。

普通版本：

```cpp
for(int i=1;i<=n;i++){
    for(int j=1;j<=m;j++){
        if(j<w[i]) f[i][j]=f[i-1][j];
        //第i件物品可能已经有了。
        else f[i][j]=max(f[i-1][j],f[i][j-w[i]]+c[i]);
    }
}
cout<<f[n][m];
```

为什么`f[i][j]=f[i][j-w[i]]+c[i]`？为什么不是`f[i][j]=f[i-1][j-w[i]]+c[i]`。这里就是01背包和完全背包的一个区别了。在完全背包当中，由于每件物品都是可以无限拿的，如果当前处于第i件物品，背包容量为j的时候，有可能背包中已经存了一个第i件物品。所以说我们需要使用`f[i][j-w[i]]+c[i]`来更新

优化版本：

```cpp
for(int i=1;i<=n;i++){
    for(int j=w[i];j<=m;j++){
        f[j]=max(f[j],f[j-w[i]]+c[i]);
    }
}
cout<<f[m];
```

### 3.多重背包：

一个容量为m公斤的背包。现有n种物品，每种物品有si(1<=i<=n)件，它们的重量分别为wi(1≤i≤n)，它们的价值分别为Ci(1≤i≤n)。求能放入背包的最大价值。

朴素算法：

```cpp
const int N=210;
int n, m;
int v[N], w[N], s[N];
int f[N][N];

int main(){
  scanf("%d%d",&n,&m);
  for(int i=1; i<=n; i++) 
    scanf("%d%d%d",&v[i],&w[i],&s[i]);  //费用,价值,数量
  
  for(int i=1; i<=n; i++)               //阶段：物品
  for(int j=0; j<=m; j++)               //状态：体积
  for(int k=0; k<=s[i]&&k*v[i]<=j; k++) //决策：个数
    f[i][j]=max(f[i][j],f[i-1][j-k*v[i]]+k*w[i]);
  printf("%d\n",f[n][m]);
}
```

二进制优化版：
原理：对于数字50，可以通过二进制拆分，拆成1，2，4，8，16，19(剩下的那个)。通过这些数字组合。可以得到1-50的任何数。相当于把第i件物品(有si件)，拆分成若干件物品,从而化归成01背包问题。

```cpp
const int N=1e5+10;
int w[N],c[N],f[N];
//第i个物品的重量为a,价值为b,数目为s,
int n,m,a,b,s;
//cnt表示拆分以后的物品个数
int cnt=0;
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++){
        //分别输入价值,重量,数目,
        cin>>b>>a>>s;
        //对数目进行拆分,用二进制拆分,j每次×2;
        for(int j=1;j<=s;j<<=1){
            w[++cnt]=j*a;
            c[cnt]=j*b;
            s-=j;
        }
        //处理剩下的那组
        if(s){
            w[++cnt]=s*a;
            c[cnt]=s*b;
        }
    }
    //然后套用01背包的板子解决问题
    for(int i=1;i<=cnt;i++){
        for(int j=m;j>=w[i];j--){
            f[j]=max(f[j],f[j-w[i]]+c[i]);
        }
    }
    cout<<f[m];
    return 0;
}
```



# 图论

### 1.邻接矩阵

![img](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250205195327425-1615679213.png)

应用：

```cpp
#include<bits/stdc++.h>
using namespace std;
//边权
const int N=1e3+10;
int w[N][N];
bool vis[N];
//n个点,m条边.
int n,m;
void dfs(int u){
	vis[u]=true;
	for(int v=1;v<=m;v++){
		//u到v有边 
		if(w[u][v]){
			printf("%d到%d的权值为：%d\n",u,v,w[u][v]);
			if(vis[v]) continue;
			dfs(v);
		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b,c;
		//a→b的边的权值为c 
		cin>>a>>b>>c;
		w[a][b]=c;
	    //无向图就加上下面这句.
        //w[b][a]=c;
	}
	dfs(1);
	return 0;
} 
```

### 2.边集数组

![](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250205201003367-682879050.jpg)

应用：

```cpp
#include<bits/stdc++.h>
using namespace std;
//边权
const int N=1e6+10;
struct node{
	int u,v,w;
}e[N];
int vis[N];
int n,m;
void dfs(int u){
	vis[u]=true;
	for(int i=1;i<=m;i++){
		//第i条边的起点为u 
		if(e[i].u==u){
			int v=e[i].v,w=e[i].w;
			printf("%d到%d的权值为:%d\n",u,v,w);
			if(vis[v]) continue;
			dfs(v);
 		}
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b,c;
		//a→b的边的权值为c 
		cin>>a>>b>>c;
		e[i]={a,b,c};
		//e[i]={b,a,c};
	}
	dfs(1);
	return 0;
} 
```

### 3.邻接表

![](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250205201416775-1286069131.png)

缺点：

没有存储边的编号，无法处理网络流中需要查找边的编号的问题.

父节点判重做法：

```cpp
#include<bits/stdc++.h>
using namespace std;
//边权
const int N=1e6+10;
struct edge{
	int v,w;
};
vector<edge> e[N];
int vis[N];
int n,m;
void dfs(int u,int fa){
	for(auto ed:e[u]){
		int v=ed.v,w=ed.w;
		if(v==fa) continue;
		printf("%d到%d的权值为:%d\n",u,v,w);
		dfs(v,u);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b,c;
		//a→b的边的权值为c 
		cin>>a>>b>>c;
		e[a].push_back({b,c});
		e[b].push_back({a,c});
	}
	dfs(1,0);
	return 0;
} 
```

vis判重做法：

```cpp
#include<bits/stdc++.h>
using namespace std;
//边权
const int N=1e6+10;
struct edge{
	int v,w;
};
vector<edge> e[N];
int vis[N];
int n,m;
void dfs(int u){
	vis[u]=true;
	for(auto ed:e[u]){
		int v=ed.v,w=ed.w;
		if(vis[v]) continue;
		printf("%d到%d的权值为:%d\n",u,v,w);
		dfs(v);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b,c;
		//a→b的边的权值为c 
		cin>>a>>b>>c;
		e[a].push_back({b,c});
		e[b].push_back({a,c});
	}
	dfs(1);
	return 0;
} 
```

### 4.链式邻接表

![](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250205205947015-616034937.png)

代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
int n,m;
const int N=1e4+10;
struct edge{
	int u,v,w;
};
vector<edge> e;
vector<int> h[N];
void add(int a,int b,int c){
	e.push_back({a,b,c});
	//边的编号从0开始，若从1开始则不需要-1 
	h[a].push_back(e.size()-1);
}
void dfs(int u,int fa){
	for(int i=0;i<h[u].size();i++){
		//第j条边 
		int j=h[u][i];
		int v=e[j].v,w=e[j].w;
		if(v==fa) continue;
		printf("%d到%d的权值为:%d\n",u,v,w);
		dfs(v,u);
	}
}
int main()
{
	cin>>n>>m;
	for(int i=1;i<=m;i++){
		int a,b,c;
		cin>>a>>b>>c;
		add(a,b,c);
		//无向边 
		add(b,a,c);
	}
	dfs(1,0);	
	return 0;
}
```

### 5.链式前向星

![](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250212222837267-1210023425.png)

链式前向星本质上是在用普通数组来模拟邻接表的过程。

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=510,M=3000;
int n,m,a,b,c;
struct edge{int v,w,ne;};
edge e[M];//边集
int idx,h[N];//点的第一条出边 

void add(int a,int b,int c){
  e[idx]={b,c,h[a]};
  h[a]=idx++;
}
void dfs(int u,int fa){
  for(int i=h[u];~i;i=e[i].ne){
    int v=e[i].v, w=e[i].w;
    if(v==fa) continue;
    printf("%d,%d,%d\n",u,v,w);
    dfs(v,u);
  }
}
int main(){
  cin>>n>>m;
  memset(h,-1,sizeof h);
  for(int i=1;i<=m;i++){
    cin>>a>>b>>c,
    add(a,b,c);
    add(b,a,c);
  }  
  dfs(1, 0);
  return 0;
}
```





# 线段树

### 1.区间和的查询/修改：

![img](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250212143119135-1837343446.png)

![img](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250212145957973-2099089036.png)

![img](https://img2024.cnblogs.com/blog/3476421/202502/3476421-20250212151316925-2096761272.png)

应用：

```cpp
#include<bits/stdc++.h>
using namespace std;
#define int long long
#define ll long long 
#define lc u<<1
#define rc u<<1|1
#define N 100005
int w[N];   //w[i]为原数组
struct Tree{
    int l,r,sum,add;
}tr[N*4];
void pushup(int u)  // 上传
{
    tr[u].sum=tr[lc].sum+tr[rc].sum;	//得注意,不是"+=",就是"="
}
void build(int u,int l,int r){
    //初始懒标记为0;
    tr[u]={l,r,w[l],0};
    if(l==r) return;    //到叶子节点就返回
    int m=l+r>>1;   //不是叶子节点就裂开
    build(lc,l,m);  
    build(rc,m+1,r);   
    pushup(u);
}
void pushdown(int u){
    if(tr[u].add){  //若还存在着懒标记,则往下传
    tr[lc].sum+=tr[u].add*(tr[lc].r-tr[lc].l+1);    //左子树继承的懒标记值为:左子树这个区间的长度*父亲的懒标记值
    tr[rc].sum+=tr[u].add*(tr[rc].r-tr[rc].l+1); //右子树同理
    tr[lc].add+=tr[u].add;      //左子树的懒标记值继承父亲传下来的懒标记值
    tr[rc].add+=tr[u].add;      //右子树同理
    tr[u].add=0;                //父亲的懒标记值清零.
   }
}
int query(int u,int l,int r)
{
    //如果当前区间被所查询的区间完全覆盖,则返回当前区间的区间和
    if(l<=tr[u].l&&r>=tr[u].r) return tr[u].sum;
    //否则,选择性去判断是访问左子树还是右子树
    int m=tr[u].l+tr[u].r>>1;
    //下传懒标记值
    pushdown(u);
    int sum=0;
    //查询的区间在左子树中有一部分,那么就去查左子树
    if(l<=m) sum+=query(lc,l,r);
    //查询的区间在右子树中有一部分,那么就查右子树
    if(r>m) sum+=query(rc,l,r);
    return sum;
}
void change(int u,int l,int r,int k){   //在[l,r]区间内都加上k
    //若当前区间已经被修改区间覆盖了
    if(l<=tr[u].l&&r>=tr[u].r){
        tr[u].sum+=(tr[u].r-tr[u].l+1)*k;
        tr[u].add+=k;
        return;
    }
    //否则就裂开,继续找
    int m=tr[u].l+tr[u].r>>1;  
    pushdown(u);    //修改之前把懒标记下传
    if(l<=m)  change(lc,l,r,k);
    if(r>m)  change(rc,l,r,k);
    pushup(u);
} 
signed main()
{
    int n, m, op, x, y, k;
    cin >> n >> m;
    for (int i = 1; i <= n; i++)  cin >> w[i];
    build(1, 1, n);
    while (m--){
        cin >> op >> x >> y;
        if (op == 2)
            cout << query(1, x, y) << endl;
        else
            cin >> k, change(1, x, y, k);
    }
    return 0;
}
```

