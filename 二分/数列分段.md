# 数列分段 Section II

https://www.luogu.com.cn/problem/P1182

## 题目描述

对于给定的一个长度为 $N$ 的正整数数列 $A_{1\sim N}$，现要将其分成 $M$（$M\leq N$）段，并要求每段连续，且每段和的最大值最小。

关于最大值最小：

例如一数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段。

将其如下分段：

$$[4\ 2][4\ 5][1]$$

第一段和为 $6$，第 $2$ 段和为 $9$，第 $3$ 段和为 $1$，和最大值为 $9$。

将其如下分段：

$$[4][2\ 4][5\ 1]$$

第一段和为 $4$，第 $2$ 段和为 $6$，第 $3$ 段和为 $6$，和最大值为 $6$。

并且无论如何分段，最大值不会小于 $6$。

所以可以得到要将数列 $4\ 2\ 4\ 5\ 1$ 要分成 $3$ 段，每段和的最大值最小为 $6$。

## 输入格式

第 $1$ 行包含两个正整数 $N,M$。  

第 $2$ 行包含 $N$ 个空格隔开的非负整数 $A_i$，含义如题目所述。

## 输出格式

一个正整数，即每段和最大值最小为多少。

## 样例 #1

### 样例输入 #1

```
5 3
4 2 4 5 1
```

### 样例输出 #1

```
6
```

## 提示

对于 $20\%$ 的数据，$N\leq 10$。

对于 $40\%$ 的数据，$N\leq 1000$。

对于 $100\%$ 的数据，$1\leq N\leq 10^5$，$M\leq N$，$A_i < 10^8$， 答案不超过 $10^9$。

## 思路：

本题是求”每段和最大值“的最小值，因此套用最小化的板子。

这里的y是求你分的段数，这里可以使用贪心思想，若当前累计和+a[i]<x(当前你所希望的每段和最大值),那么就累加上a[i]，否则就新开一段。

这里值得注意的是：二分的左边界最低都得是数组中元素最小的那个-1，因为你如果最少都是一个人分一段，那么这个”每段和的最大值“最小都得是数组当中最大的那个元素。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=1e5+10;
int a[N];
int n,m,mx;
bool check(int x){
    int cnt=1,sum=0;
    for(int i=1;i<=n;i++){
        if(sum+a[i]<=x) sum+=a[i];
        else cnt++,sum=a[i];
    }
    return cnt<=m;
}
int find(){
    //这里需要注意，二分的时候，左边界不能为0，
    //而是最小都得是数组中最大元素-1,因为你最少都是一个元素一组，和的最小值一定是mx(数组中最大的哪个元素的值)
    int l=mx-1,r=1e9+1;
    while(l+1<r){
        int mid=l+r>>1;
        if(check(mid)) r=mid;
        else l=mid;
    }
    return r;
}
int main()
{
    cin>>n>>m;
    for(int i=1;i<=n;i++) cin>>a[i],mx=max(mx,a[i]);
    cout<<find();
    return 0;
}
```

