https://ac.nowcoder.com/acm/contest/20960/1032



相信大家都玩过扫雷的游戏。那是在一个n*m的矩阵里面有一些雷，要你根据一些信息找出雷来。

万圣节到了 ，“余”人国流行起了一种简单的扫雷游戏，这个游戏规则和扫雷一样，如果某个格子没有雷，那么它里面的数字 表示和它8连通的格子里面雷的数目。

现在棋盘是n×2的，第一列里面某些格子是雷，而第二列没有雷，如下图： 由于第一列的雷可能有多种方案满足第二列的数的限制，你的任务即根据第二列的信息确定第一列雷有多少种摆放方案。

## 思路：

这段代码的主要思想是解决特定规则下扫雷游戏中第一列雷的摆放方案计数问题，具体如下：

首先，通过输入获取棋盘第一列的格子数量（即整个棋盘的行数）以及第二列每个格子所对应的表示周围雷数量的数字，以此确定游戏的基本设定信息。

然后，核心思想在于通过枚举第一列第一个格子放置雷的所有可能情况（从 0 个雷到第二列第一个格子所提示数量个雷），在确定第一个格子放雷情况后，利用第二列给定的每个格子周边雷数的信息，按照规则以递推的方式去推算出整个第一列其他格子放置雷的相应情况（依据第二列某格对应的雷数减去与之关联的已推得的前两个第一列格子放雷数量，来确定当前第一列格子放雷数量）。

最后，对每一种完整推算出的第一列雷的放置情况进行合法性检查（通过检查按照递推逻辑得到的最后一个相关值是否为 0 来判断整体情况是否符合规则），如果合法就对满足条件的摆放方案数量进行统计，最终输出统计得到的第一列雷的摆放方案的总数。

简单概括就是通过枚举和递推结合的方式，基于游戏规则去尝试所有可能的第一列雷的放置情况，筛选出合法的方案并计数输出。

## 代码：

```cpp
#include<bits/stdc++.h>
using namespace std;
const int N=10000+10;
int a[N],f[N],ans;
int main()
{
    int n;cin>>n;
    for(int i=1;i<=n;i++) cin>>a[i];
    for(int i=0;i<=a[1];i++){
        f[1]=i;
        for(int j=2;j<=n+1;j++) f[j]=a[j-1]-f[j-1]-f[j-2];
        if(f[n+1]==0) ans++;
    }
    cout<<ans;
    return 0;
}
```

